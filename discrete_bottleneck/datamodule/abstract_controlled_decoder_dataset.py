from torch.utils.data import Dataset


class AbstractControlledDecoderDataset(Dataset):
    """
    An abstract class for a torch.utils.data.Dataset of numeric sequences generated by a decoder f
    from a specified discrete structure Z.
    f can have a combination of the following properties:
        - deterministic vs. stochastic
        - invertible vs. non-invertible
        - real number output vs. sequence outputs
    Z can be any of the following structures:
        - One discrete variable with 2 possible values (1 bit of information)
        - One discrete variable with n possible values
        - M discrete variables, each with n possible values (cross-product space)
        - Compositional, grammar-like

    Any dataset of this type should implement the following functions:
        * _decode(self, z)
            This function should take a sample z from the discrete structure Z defined in the __init__
            and decode it based on the decoding function specified in _decode()

        * _generate_data(self)
            Based on the type of discrete structure Z, it should generate either all deterministic
            samples, or as many stochastic samples as requested.
    """

    def __init__(self, split, seed, **kwargs):
        """
        Parameters
        ----------
        split : The split to load. Must be equal to 'train', 'val' or 'test'.
        seed : Random seed

        kwargs: generator function's parameters

        Returns
        -------
        An instance of the Grid dataset that extends torch.utils.data.Dataset.
        """
        super().__init__()
        self.params = kwargs

        assert split in {"train", "val", "test"}, "Unexpected split reference"
        if split == "val":
            seed += 10
        elif split == "test":
            seed += 23
        self.params["seed"] = seed

        self.use_mapping = False

        if "mappings" in kwargs.keys():
            self.use_mapping = True
            self.mappings = kwargs["mappings"]

        self.data, self.sampled_latents = self._generate_data()

    def _generate_data(self):
        raise NotImplementedError()

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        return {"id": self.data[idx][0], "text": self.data[idx][1], "latent": self.sampled_latents[idx]}
